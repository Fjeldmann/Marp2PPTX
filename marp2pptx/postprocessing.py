"""Postprocessing functions for PPTX files generated by Marp."""

import copy
import logging
import os
import re
import tempfile
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple

from pptx.presentation import Presentation as PresentationType
from pptx.enum.shapes import MSO_SHAPE_TYPE
from pptx.dml.color import RGBColor
from pptx.util import Cm
from bs4 import BeautifulSoup, Tag
from PIL import Image

from .render_div_as_image import main as render_div_as_image

# --- Types / Aliases ---
MarpSlideData = Dict[str, Any]
MarpBackground = Dict[str, Any]
Shape = Any  # from python-pptx, but no stubs available

logger = logging.getLogger(__name__)


def extract_images_from_tag(tag: Tag) -> List[Dict[str, str]]:
    """Return a list of image descriptors found on a Tag (inline <img> and CSS background-image).

    Kept as a top-level helper so it can be unit-tested and reused by
    `parse_marp_html`.
    """
    images: List[Dict[str, str]] = []
    if tag.name == "img" and tag.has_attr("src"):
        src_val = tag.get("src")
        if src_val is not None:
            images.append({"url": str(src_val), "source": "img"})
    if tag.has_attr("style"):
        style = str(tag.get("style", ""))
        # match url(...) where the closing paren is followed by a semicolon or end
        m = re.search(r'background-image\s*:\s*url\((?:["\']?)(.+?)(?:["\']?)\)\s*(?=;|$)', style)
        if m:
            images.append({"url": m.group(1), "source": "background-image"})
    return images

def parse_marp_html(html_path: Path) -> List[MarpSlideData]:
    """
    Parse Marp HTML and extract slide backgrounds, split info, image URLs, and layout instructions.
    Returns a list of dicts: { backgrounds: [...], content: ... }
    """
    with open(html_path, encoding="utf-8") as f:
        html = f.read()
    soup = BeautifulSoup(html, "html.parser")
    slides: List[MarpSlideData] = []
    svg_elements: List[Tag] = soup.find_all("svg", attrs={"data-marpit-svg": True})

    for svg in svg_elements:
        slide: MarpSlideData = {"backgrounds": [], "content": None, "all_images": []}

        bg_section: Optional[Tag] = None
        for fo in svg.find_all("foreignobject"):
            sec = fo.find(
                "section", attrs={"data-marpit-advanced-background": "background"}
            )
            if sec:
                bg_section = sec
                break

        if bg_section:
            bg_container = bg_section.find(
                "div", attrs={"data-marpit-advanced-background-container": True}
            )
            direction = (
                bg_container.get(
                    "data-marpit-advanced-background-direction", "horizontal"
                )
                if bg_container
                else "horizontal"
            )
            split = bg_section.get("data-marpit-advanced-background-split")
            split_pct = None
            if bg_section.has_attr("style"):
                m = re.search(
                    r"--marpit-advanced-background-split:([0-9.]+)%",
                    str(bg_section.get("style", "")),
                )
                if m:
                    split_pct = float(m.group(1))

            figures: List[Tag] = bg_container.find_all("figure") if bg_container else []
            for fig in figures:
                bg_url: Optional[str] = None
                bg_size = "cover"
                if fig.has_attr("style"):
                    fig_style = str(fig.get("style", ""))
                    m_url = re.search(
                        r'background-image\s*:\s*url\((?:["\']?)(.+?)(?:["\']?)\)\s*(?=;|$)', fig_style
                    )
                    if m_url:
                        bg_url = m_url.group(1)
                    m_size = re.search(r"background-size:\s*([^;]+)", fig_style)
                    if m_size:
                        bg_size = m_size.group(1).strip()

                slide["backgrounds"].append(
                    {
                        "url": bg_url,
                        "direction": direction,
                        "split": split,
                        "split_pct": split_pct,
                        "size": bg_size,
                    }
                )
                if bg_url:
                    slide["all_images"].append({"url": bg_url, "source": "background"})

        content_section: Optional[Tag] = None
        for fo in svg.find_all("foreignobject"):
            sec: Optional[Tag] = fo.find(
                "section", attrs={"data-marpit-advanced-background": "content"}
            )
            if sec:
                content_section = sec
                # Extract images from section (this automatically includes header)
                for tag in sec.find_all(["img", "figure"]):
                    slide["all_images"].extend(extract_images_from_tag(tag))
                break

        # Fallback: some Marp sections do not include the 'data-marpit-advanced-background'
        # attribute. If we didn't find an explicit content section above, use the first
        # non-background/non-pseudo <section> as the content section so we can still
        # detect images and styled divs (e.g. `.portrait-wrap` / `.portrait-wrap-circle`).
        if not content_section:
            for fo in svg.find_all("foreignobject"):
                sec = fo.find("section")
                if not sec:
                    continue
                attr = sec.get("data-marpit-advanced-background")
                if attr in ("background", "pseudo"):
                    continue
                # treat this as the content section
                content_section = sec
                # Extract images from section (this automatically includes header)
                for tag in sec.find_all(["img", "figure"]):
                    slide["all_images"].extend(extract_images_from_tag(tag))
                break

        if content_section:
            slide["content"] = str(content_section)

        slides.append(slide)
    return slides


def _calculate_background_region(
    slide_width: int,
    slide_height: int,
    i: int,
    n: int,
    direction: str,
    is_split_stack: bool,
    split_dir: Optional[str] = None,
    split_pct: Optional[float] = None,
) -> Tuple[int, int, int, int]:
    """Return (left, top, width, height) for a background region.

    Pure computation extracted from `process_pptx_html` to make the
    layout logic easier to test.
    """
    region_left, region_top, region_width, region_height = (
        0,
        0,
        slide_width,
        slide_height,
    )

    if is_split_stack:
        assert split_pct is not None
        pct = float(split_pct) / 100.0
        split_region_width = int(slide_width * pct)
        split_region_left = (
            0 if split_dir == "left" else slide_width - split_region_width
        )
        split_region_height = slide_height

        if direction == "horizontal":
            region_left = split_region_left + int(split_region_width * i / n)
            region_width = int(split_region_width / n)
            if i == n - 1:
                region_width = split_region_left + split_region_width - region_left
            region_top, region_height = 0, split_region_height
        else:  # vertical
            region_left, region_width = split_region_left, split_region_width
            region_top = int(split_region_height * i / n)
            region_height = int(split_region_height / n)
            if i == n - 1:
                region_height = split_region_height - region_top
    else:  # Regular stacking
        if direction == "horizontal":
            region_left = int(slide_width * i / n)
            region_width = int(slide_width / n)
            if i == n - 1:
                region_width = slide_width - region_left
            region_top, region_height = 0, slide_height
        else:  # vertical
            region_top = int(slide_height * i / n)
            region_height = int(slide_height / n)
            if i == n - 1:
                region_height = slide_height - region_top
            region_left, region_width = 0, slide_width

    return region_left, region_top, region_width, region_height


def widen_text_shapes(prs: PresentationType, extra_width_cm: float = 1.0) -> None:
    """Increase width of all text-containing shapes to avoid undesirable wrapping.

    Adjust text box widths in PPTX to prevent wrapping issues. The helper uses
    `pptx.util.Cm(...)` to express the default increment in centimetres for
    clarity while preserving the previous numeric behaviour.

    This helper modifies the given ``prs`` in-place.

    Args:
        prs: python-pptx ``Presentation`` object to modify in-place.
        extra_width_cm: optional float amount (in centimetres) to add to each text shape's width.
            If ``None``, the default amount (expressed with `Cm`) is used to preserve historic behaviour.
    """
    for slide in prs.slides:
        for shape in slide.shapes:
            if shape.shape_type in (MSO_SHAPE_TYPE.TEXT_BOX, MSO_SHAPE_TYPE.PLACEHOLDER):
                shape.width = shape.width + Cm(extra_width_cm).emu


def merge_multiline_textboxes(
    prs: PresentationType,
    position_tolerance_emu: int = 50000,
    gap_tolerance_emu: int = 100000,
) -> int:
    """Merge consecutive text boxes from the same wrapped sentence into one text box.

    When Marp CLI exports long text or headings to PPTX via LibreOffice, text that
    wraps to multiple visual lines is split into multiple adjacent text boxes (one
    per line). This function detects chains of vertically-adjacent text boxes with
    the same left alignment and merges them into a single text box, preserving
    each original box as a paragraph so line wrapping is retained.

    Detection criteria for a mergeable chain:
    - All shapes are TEXT_BOX (not placeholders, not rotated).
    - Consecutive boxes in the chain share the same ``left`` position (within
      ``position_tolerance_emu``).
    - Each consecutive pair is vertically adjacent: the absolute difference
      between the top of the next box and the bottom of the current box is within
      ``gap_tolerance_emu``.  Both small positive gaps and slight overlaps (common
      in LibreOffice-generated PPTX) are accepted.

    Args:
        prs: python-pptx ``Presentation`` object to modify in-place.
        position_tolerance_emu: maximum horizontal misalignment (EMU) tolerated
            when matching text boxes to the same chain.
        gap_tolerance_emu: maximum vertical gap or overlap (EMU) between
            consecutive boxes in a chain.

    Returns:
        Total number of text boxes removed across all slides.
    """
    _NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
    removed = 0

    for slide_idx, slide in enumerate(prs.slides):
        # Collect candidate text boxes: TEXT_BOX, not placeholder, not rotated, non-empty
        candidates: List[Any] = []
        for shape in slide.shapes:
            if shape.shape_type != MSO_SHAPE_TYPE.TEXT_BOX:
                continue
            if getattr(shape, "is_placeholder", False):
                continue
            if getattr(shape, "rotation", 0) not in (0, None):
                continue
            if not getattr(shape, "has_text_frame", False) or not shape.has_text_frame:
                continue
            if not shape.text_frame.text.strip():
                continue
            candidates.append(shape)

        if len(candidates) < 2:
            continue

        # Sort by top position (primary), then left (secondary)
        candidates.sort(key=lambda s: (s.top, s.left))

        # Build chains: each chain is a list of boxes forming one wrapped sentence
        chains: List[List[Any]] = []
        used: set = set()

        for i, box in enumerate(candidates):
            if i in used:
                continue
            chain = [box]
            used.add(i)

            # Walk down: extend the chain with the best-matching next box
            while True:
                current = chain[-1]
                current_bottom = current.top + current.height
                best_j: Optional[int] = None
                best_gap = float("inf")
                for j, next_box in enumerate(candidates):
                    if j in used:
                        continue
                    # Must have approximately the same left as the chain anchor
                    if abs(next_box.left - chain[0].left) > position_tolerance_emu:
                        continue
                    # Must be vertically adjacent (positive gap or slight overlap)
                    gap = abs(next_box.top - current_bottom)
                    if gap <= gap_tolerance_emu and gap < best_gap:
                        best_gap = gap
                        best_j = j
                if best_j is not None:
                    chain.append(candidates[best_j])
                    used.add(best_j)
                else:
                    break

            if len(chain) > 1:
                chains.append(chain)

        # Merge each chain into the first (primary) box
        for chain in chains:
            primary = chain[0]
            last = chain[-1]

            # Extend the primary box height to encompass all boxes in the chain
            primary.height = (last.top + last.height) - primary.top

            # Append paragraphs from subsequent boxes to the primary text frame
            primary_txBody = primary.text_frame._txBody
            for box in chain[1:]:
                src_txBody = box.text_frame._txBody
                for para_elem in src_txBody.findall(f"{{{_NS}}}p"):
                    primary_txBody.append(copy.deepcopy(para_elem))
                # Remove this box from the slide
                box._element.getparent().remove(box._element)
                removed += 1

            logger.debug(
                "slide %d: merged %d text boxes into one",
                slide_idx,
                len(chain),
            )

        if chains:
            logger.info(
                "slide %d: merged %d chain(s), removed %d text box(es)",
                slide_idx,
                len(chains),
                sum(len(c) - 1 for c in chains),
            )

    return removed


def _normalize_font_runs(runs: "List[Any]", mapping: "Dict[str, str]") -> int:
    """Normalize font names on a sequence of runs and return number of changes."""
    changed = 0
    for run in runs:
        try:
            name = run.font.name
        except Exception:
            name = None
        if not name:
            continue
        key = name.strip().lower()
        replacement = mapping.get(key)
        if replacement and name != replacement:
            run.font.name = replacement
            changed += 1
    return changed


def normalize_font_names(prs: PresentationType) -> None:
    """Normalize known incorrect font names inside a Presentation.

    - Fix explicit run-level font names (e.g. `SegoeUI` -> `Segoe UI`).
    - Apply a targeted replacement in theme XML parts so inherited/theme-default
      fonts are corrected as well.

    This mutates ``prs`` in-place.
    """
    # Known font-name normalizations (lower-case keys -> canonical replacement)
    # Extend this mapping if additional Marp->PPTX font-name mismatches are discovered.
    DEFAULT_FONT_NORMALIZATIONS: Dict[str, str] = {"segoeui": "Segoe UI"}

    replaced_runs = 0
    # Run-level pass: explicit run.font.name overrides
    for slide in prs.slides:
        for shape in slide.shapes:
            try:
                if getattr(shape, "has_text_frame", False) and shape.has_text_frame:
                    for paragraph in shape.text_frame.paragraphs:
                        replaced_runs += _normalize_font_runs(paragraph.runs, DEFAULT_FONT_NORMALIZATIONS)
                if getattr(shape, "has_table", False) and shape.has_table:
                    for row in shape.table.rows:
                        for cell in row.cells:
                            for paragraph in cell.text_frame.paragraphs:
                                replaced_runs += _normalize_font_runs(paragraph.runs, DEFAULT_FONT_NORMALIZATIONS)
            except Exception:
                logger.debug("normalize_font_names: failed to inspect shape", exc_info=True)
    if replaced_runs:
        logger.info(f"normalize_font_names: updated {replaced_runs} explicit run font name(s)")

    # Theme-part pass: targeted XML edits for theme parts (safe, small changes)
    replaced_theme_parts = 0
    try:
        for rel in prs.part.rels.values():
            if rel.reltype.endswith("/theme"):
                part = rel._target
                # safely obtain bytes from either _blob or blob attributes
                blob_bytes = getattr(part, "_blob", None) or getattr(part, "blob", None)
                if not isinstance(blob_bytes, (bytes, bytearray)):
                    # unexpected part type; skip
                    continue
                try:
                    blob = blob_bytes.decode("utf-8")
                except Exception:
                    blob = blob_bytes.decode("utf-8", errors="ignore")
                updated = blob
                for bad, good in DEFAULT_FONT_NORMALIZATIONS.items():
                    # replace bare occurrences and typeface attribute values (case-insensitive)
                    updated = re.sub(rf"\b{re.escape(bad)}\b", good, updated, flags=re.IGNORECASE)
                    updated = re.sub(rf'(typeface\s*=\s*")([^\"]*{re.escape(bad)}[^\"]*)(")', rf"\1{good}\3", updated, flags=re.IGNORECASE)
                if updated != blob:
                    # assign back to the part using setattr to keep type-checkers happy
                    setattr(part, "_blob", updated.encode("utf-8"))
                    replaced_theme_parts += 1
    except Exception:
        logger.debug("normalize_font_names: theme-part normalization failed", exc_info=True)

    if replaced_theme_parts:
        logger.info(f"normalize_font_names: updated {replaced_theme_parts} theme part(s)")


def remove_redundant_marp_white_rectangles(
    prs: PresentationType,
    *,
    px_tolerance: int = 4,
    require_count: int = 3,
    dry_run: bool = False,
) -> int:
    """
    Remove redundant full-slide white rectangle shapes emitted by some Marp
    exporters.

    Detection rules (stricter):
    - shape.shape_type == MSO_SHAPE_TYPE.AUTO_SHAPE
    - not a placeholder
    - rotation == 0
    - explicit RGB white fill (fore_color.rgb == RGBColor(255,255,255))
    - left/top within `px_tolerance` (px) of 0
    - width/height either within `px_tolerance` OR within 1% of slide size

    Removal rules:
    - require exactly `require_count` candidates on a slide
    - candidates must be the back-most shapes (all candidate indices < any non-candidate index)
    - skip removal if the slide contains ONLY the candidate shapes
    - remove via direct XML removal; return either 0 or `require_count`

    `dry_run=True` will only log what would be removed and return 0.
    """
    # convert px tolerance -> EMU (assume 96 DPI)
    EMU_PER_PX = 9525
    tol_emu = int(px_tolerance * EMU_PER_PX)

    slide_w = getattr(prs, "slide_width", None)
    slide_h = getattr(prs, "slide_height", None)
    if slide_w is None or slide_h is None:
        logger.error(
            "remove_redundant_marp_white_rectangles: slide dimensions not found on presentation"
        )
        return 0

    def _shape_is_candidate(sh) -> bool:
        try:
            # explicit white RGB fill
            shape_type = getattr(sh, "shape_type", None)
            is_placeholder = getattr(sh, "is_placeholder", None)
            rotation = getattr(sh, "rotation", None)
            fill = getattr(sh, "fill", None)
            fore = getattr(fill, "fore_color", None)
            rgb = getattr(fore, "rgb", None)
            left = getattr(sh, "left", None)
            top = getattr(sh, "top", None)
            logger.debug(
                f"Inspecting shape (left={left} top={top} fill_rgb={rgb} shape_type={shape_type} is_placeholder={is_placeholder} rotation={rotation})"
            )
            # shape-type / placeholder / rotation — accept both FREEFORM (LibreOffice output)
            # and AUTO_SHAPE (python-pptx add_shape) so tests and real Marp output
            # are both handled.
            if shape_type not in (MSO_SHAPE_TYPE.FREEFORM, MSO_SHAPE_TYPE.AUTO_SHAPE):
                return False
            if is_placeholder:
                return False
            if rotation is None or abs(rotation) != 0:
                return False
            if fill is None:
                return False
            if fore is None:
                return False
            if rgb is None:
                return False
            if rgb != RGBColor(255, 255, 255):
                return False

            # position within tolerance of (0,0)

            if left is None or top is None:
                return False
            if abs(int(left)) > tol_emu or abs(int(top)) > tol_emu:
                return False

            # width/height within px tolerance OR within 1%
            w = getattr(sh, "width", None)
            h = getattr(sh, "height", None)
            if w is None or h is None:
                return False

            w_ok = abs(int(w) - int(slide_w)) <= tol_emu or abs(int(w) - int(slide_w)) <= int(slide_w * 0.01)
            h_ok = abs(int(h) - int(slide_h)) <= tol_emu or abs(int(h) - int(slide_h)) <= int(slide_h * 0.01)
            if not (w_ok and h_ok):
                return False

            return True
        except Exception:
            return False

    total_removed = 0

    for slide_index, slide in enumerate(prs.slides):
        # enumerate shapes so we can reason about indices (z-order)
        indexed_shapes = list(enumerate(list(slide.shapes)))
        candidate_entries = [entry for entry in indexed_shapes if _shape_is_candidate(entry[1])]
        if len(candidate_entries) != require_count:
            logger.debug(
                "slide %d: candidate count %d != required %d -> skipping",
                slide_index,
                len(candidate_entries),
                require_count,
            )
            continue

        candidate_indices = [idx for idx, _ in candidate_entries]
        non_candidate_indices = [idx for idx, _ in indexed_shapes if idx not in candidate_indices]

        # If there are no non-candidate shapes the slide consists only of the
        # candidate rectangles — this is the Marp-empty-slide case and we
        # should still remove the artefacts. Only enforce the back-most
        # z-order check when there *are* non-candidate shapes on the slide.
        if non_candidate_indices:
            # ensure candidates are strictly less than any non-candidate index (back-most)
            if max(candidate_indices) >= min(non_candidate_indices):
                logger.debug(
                    "slide %d: candidates are not strictly back-most (candidate max %d >= non-candidate min %d) -> skipping",
                    slide_index,
                    max(candidate_indices),
                    min(non_candidate_indices),
                )
                continue

        # At this point we will remove all candidate shapes (or none on failure)
        logger.info(
            "slide %d: removing %d redundant white rectangle candidate(s)",
            slide_index,
            require_count,
        )

        if dry_run:
            logger.debug("dry_run set -> not actually removing shapes on slide %d", slide_index)
            continue

        try:
            # remove via XML parent removal for each candidate element
            for _idx, sh in candidate_entries:
                sh._element.getparent().remove(sh._element)
            total_removed += require_count
        except Exception:
            logger.debug(
                "slide %d: failed to remove candidate shapes", slide_index, exc_info=True
            )
            # if any removal failed, return 0 for this slide (consistent, all-or-nothing)
            continue

    if total_removed:
        logger.info(
            "remove_redundant_marp_white_rectangles: removed %d shape(s)", total_removed
        )
    return total_removed


def process_native_marp_images(
    prs: PresentationType,
    slides_data: List[MarpSlideData],
) -> None:
    """
    Apply native Marp image/background layout rules to PPTX picture shapes.

    This function reproduces Marpit's native image/background behaviour in the
    post-processing step so the exported PPTX visually matches Marp's HTML
    output (see Marpit image syntax: https://marpit.marp.app/image-syntax).

    The Marp->PPTX exporter can lose or mis-apply sizing/cropping semantics
    for native image/background constructs (cover/contain/percent/auto,
    split backgrounds, stacking direction).  This helper computes the same
    layout decisions and applies crop/position/size to the corresponding
    `python-pptx` picture shapes.
    """
    slide_width = int(prs.slide_width) if prs.slide_width is not None else 0
    slide_height = int(prs.slide_height) if prs.slide_height is not None else 0
    for idx, slide in enumerate(prs.slides):
        logger.debug(f"Processing Slide {idx + 1} (native Marp images)")
        if idx >= len(slides_data):
            break

        slide_data = slides_data[idx]
        marp_backgrounds = slide_data.get("backgrounds", [])
        all_marp_images = slide_data.get("all_images", [])

        if not marp_backgrounds:
            continue

        pptx_pics = [s for s in slide.shapes if s.shape_type == MSO_SHAPE_TYPE.PICTURE]

        if len(pptx_pics) != len(all_marp_images):
            logger.warning(
                f"  Slide {idx + 1}: Mismatch in image count! "
                f"HTML has {len(all_marp_images)}, PPTX has {len(pptx_pics)}. "
                "Mapping may be incorrect."
            )

        bg_shapes_and_props: List[Tuple[Shape, MarpBackground]] = []
        bg_info_iterator = iter(marp_backgrounds)

        for i, marp_image in enumerate(all_marp_images):
            if i >= len(pptx_pics):
                break

            if marp_image.get("source") == "background":
                try:
                    shape = pptx_pics[i]
                    bg_props = next(bg_info_iterator)
                    bg_shapes_and_props.append((shape, bg_props))
                    logger.debug(
                        f"  Mapped image {i} as a background: {bg_props.get('url')}"
                    )
                except StopIteration:
                    logger.warning(
                        f"  Slide {idx + 1}: More 'background' source images found than background property sets."
                    )
                    break

        if not bg_shapes_and_props:
            continue

        n = len(bg_shapes_and_props)
        first_bg_props = bg_shapes_and_props[0][1]
        direction = first_bg_props.get("direction", "horizontal")
        split_dir = first_bg_props.get("split")
        split_pct = first_bg_props.get("split_pct", None)
        is_split_stack = split_dir in ("left", "right") and split_pct is not None

        for i, (shape, bg_props) in enumerate(bg_shapes_and_props):
            region_left, region_top, region_width, region_height = (
                _calculate_background_region(
                    slide_width,
                    slide_height,
                    i,
                    n,
                    direction,
                    is_split_stack,
                    split_dir,
                    split_pct,
                )
            )

            # --- Apply Cropping and Sizing ---
            try:
                img_width_px, img_height_px = shape.image.size
            except Exception as e:
                logger.warning(
                    f"  Could not get image size for {bg_props.get('url')}: {e}. Skipping crop."
                )
                continue

            if (
                region_height <= 0
                or region_width <= 0
                or img_height_px <= 0
                or img_width_px <= 0
            ):
                logger.warning(
                    "  Skipping crop due to zero dimension in region or image."
                )
                continue

            target_aspect = region_width / region_height
            img_aspect = img_width_px / img_height_px
            bg_size = bg_props.get("size", "cover").strip()

            crop_left, crop_right, crop_top, crop_bottom = 0.0, 0.0, 0.0, 0.0
            shape_left, shape_top, shape_width, shape_height = (
                region_left,
                region_top,
                region_width,
                region_height,
            )

            if bg_size == "fit":
                bg_size = "contain"

            if bg_size == "cover":
                if img_aspect > target_aspect:
                    new_width_px = int(img_height_px * target_aspect)
                    crop_px = (img_width_px - new_width_px) // 2
                    crop_left = crop_right = crop_px / img_width_px
                else:
                    new_height_px = int(img_width_px / target_aspect)
                    crop_px = (img_height_px - new_height_px) // 2
                    crop_top = crop_bottom = crop_px / img_height_px
            elif bg_size == "contain":
                if img_aspect > target_aspect:
                    shape_width = region_width
                    shape_height = int(region_width / img_aspect)
                    shape_top = region_top + (region_height - shape_height) // 2
                else:
                    shape_height = region_height
                    shape_width = int(region_height * img_aspect)
                    shape_left = region_left + (region_width - shape_width) // 2
            elif "auto" in bg_size or "%" in bg_size or "px" in bg_size:
                try:
                    # default values
                    crop_left = crop_right = crop_top = crop_bottom = 0.0
                    shape_left = region_left
                    shape_top = region_top
                    shape_width = region_width
                    shape_height = region_height

                    # Marp uses a 1280 CSS‑px reference for slides — convert CSS px -> EMU
                    emu_per_css_px = slide_width / 1280.0

                    # Parse background-size which may be one- or two-value (e.g. "90%", "90% auto", "auto 90%", "auto", "200px", "200px auto")
                    tokens = bg_size.lower().split()
                    new_width_emu = None
                    new_height_emu = None

                    if len(tokens) == 1:
                        tok = tokens[0]
                        if tok == "auto":
                            # intrinsic image size (CSS px -> EMU)
                            new_width_emu = int(img_width_px * emu_per_css_px)
                            new_height_emu = int(img_height_px * emu_per_css_px)
                        else:
                            # Try percentage first
                            m = re.search(r"(\d+(?:\.\d+)?)%", tok)
                            if m:
                                width_scale = float(m.group(1)) / 100.0
                                new_width_emu = int(region_width * width_scale)
                                # height auto -> preserve aspect ratio
                                new_height_emu = int(new_width_emu / img_aspect)
                            else:
                                # Try pixels
                                m = re.search(r"(\d+(?:\.\d+)?)px", tok)
                                if m:
                                    css_px = float(m.group(1))
                                    new_width_emu = int(css_px * emu_per_css_px)
                                    # height auto -> preserve aspect ratio
                                    new_height_emu = int(new_width_emu / img_aspect)
                                else:
                                    raise ValueError(
                                        f"Could not parse size from '{bg_size}'"
                                    )
                    else:
                        # two-value syntax: width then height
                        wtok, htok = tokens[0], tokens[1]
                        # width token
                        if wtok == "auto":
                            new_width_emu = None
                        else:
                            # Try percentage first
                            m = re.search(r"(\d+(?:\.\d+)?)%", wtok)
                            if m:
                                new_width_emu = int(
                                    region_width * (float(m.group(1)) / 100.0)
                                )
                            else:
                                # Try pixels
                                m = re.search(r"(\d+(?:\.\d+)?)px", wtok)
                                if m:
                                    css_px = float(m.group(1))
                                    new_width_emu = int(css_px * emu_per_css_px)
                                else:
                                    raise ValueError(
                                        f"Could not parse width from '{bg_size}'"
                                    )
                        # height token
                        if htok == "auto":
                            new_height_emu = None
                        else:
                            # Try percentage first
                            m = re.search(r"(\d+(?:\.\d+)?)%", htok)
                            if m:
                                new_height_emu = int(
                                    region_height * (float(m.group(1)) / 100.0)
                                )
                            else:
                                # Try pixels
                                m = re.search(r"(\d+(?:\.\d+)?)px", htok)
                                if m:
                                    css_px = float(m.group(1))
                                    new_height_emu = int(css_px * emu_per_css_px)
                                else:
                                    raise ValueError(
                                        f"Could not parse height from '{bg_size}'"
                                    )

                        # compute missing dimension from aspect ratio if needed
                        if new_width_emu is None and new_height_emu is None:
                            new_width_emu = int(img_width_px * emu_per_css_px)
                            new_height_emu = int(img_height_px * emu_per_css_px)
                        elif new_width_emu is None:
                            new_width_emu = int(new_height_emu * img_aspect)
                        elif new_height_emu is None:
                            new_height_emu = int(new_width_emu / img_aspect)

                    # now new_width_emu/new_height_emu are in EMU (same unit as region_width)
                    # Ensure the optionals are resolved for the type checker and at runtime.
                    assert new_width_emu is not None and new_height_emu is not None
                    new_width = int(new_width_emu)
                    new_height = int(new_height_emu)

                    # For explicit sizing (%, px, auto), always honor the specified size.
                    # Center the image and let it overflow if needed - don't apply cover-like cropping.
                    # This matches Marp's HTML behavior where percentage/pixel sizes are respected.
                    shape_width = int(new_width)
                    shape_height = int(new_height)
                    shape_left = region_left + (region_width - int(new_width)) // 2
                    shape_top = region_top + (region_height - int(new_height)) // 2

                except (ValueError, ZeroDivisionError) as e:
                    logger.warning(
                        f"  Could not parse background-size '{bg_size}': {e}. Defaulting to cover."
                    )
                    if img_aspect > target_aspect:
                        new_width_px = int(img_height_px * target_aspect)
                        crop_px = (img_width_px - new_width_px) // 2
                        crop_left = crop_right = float(crop_px) / img_width_px
                    else:
                        new_height_px = int(img_width_px / target_aspect)
                        crop_px = (img_height_px - new_height_px) // 2
                        crop_top = crop_bottom = float(crop_px) / img_height_px
                    shape_left, shape_top, shape_width, shape_height = (
                        region_left,
                        region_top,
                        region_width,
                        region_height,
                    )

            # Apply transformations
            shape.crop_left, shape.crop_right = crop_left, crop_right
            shape.crop_top, shape.crop_bottom = crop_top, crop_bottom
            shape.left, shape.top = shape_left, shape_top
            shape.width, shape.height = shape_width, shape_height


def process_styled_divs(
    prs: PresentationType,
    slides_data: List[MarpSlideData],
    html_path: Path,
    save_rendered_divs: bool = False,
) -> None:
    """
    Render styled HTML <div> elements (non-native Marp markup) and apply the
    resulting images into the given Presentation.

    Background / bug being fixed
    ----------------------------
    Marp's PPTX exporter correctly maps native/background images, but it does
    not preserve arbitrary/custom HTML + CSS used inside slides (for example
    `.portrait-wrap`, rounded/circular images, `object-fit`/`object-position`,
    inline `border-radius`, background-image on a `div`, or transform:scale).
    That conversion gap causes the PPTX to contain plain picture shapes that
    visually differ from the original HTML/CSS output.

    This helper implements a best-effort pipeline to close that gap by:
    - rasterizing styled `<div>`s from the original HTML (preserves border-radius,
      object-fit/position, transforms, and background-image styling),
    - then replacing or inserting picture shapes in the PPTX so the slide
      appearance matches the authored HTML.

    Behavioural notes
    - This operates on *custom* HTML/CSS (non-basic/native Marp syntax) —
      unlike the earlier background cropping logic which handles native Marp
      backgrounds, this function targets arbitrary styled containers produced
      by advanced Marp input.
    - Replacement strategy is best-effort: prefer in-place image-part replacement
      (preserves formatting), fall back to shape-replacement, nearest-small-pic
      replacement, or finally adding a full-width picture.
    - Rendered PNGs are removed by default unless `save_rendered_divs` is True
      and `rendered_output_dir` is provided.

    Args:
        prs: open `Presentation` object to mutate.
        slides_data: parsed Marp HTML slide metadata (returned from `parse_marp_html`).
        html_path: path to the Marp-generated HTML (used to extract global CSS).
        save_rendered_divs: keep rendered PNG copies when True.
    """

    # derive slide dimensions from the Presentation (same logic used elsewhere)
    slide_width = int(prs.slide_width) if prs.slide_width is not None else 0
    slide_height = int(prs.slide_height) if prs.slide_height is not None else 0

    # read global CSS from the Marp HTML so class-based rules (border-radius,
    # overflow, transforms) are preserved when rendering divs
    global_css = ""
    try:
        with open(html_path, encoding="utf-8") as _f:
            _full_html = _f.read()
        _soup_html = BeautifulSoup(_full_html, "html.parser")
        global_css = "\n".join([s.get_text() for s in _soup_html.find_all("style")])
    except Exception:
        logger.debug("process_styled_divs: could not read global CSS from %s", html_path)

    for idx, slide in enumerate(prs.slides):
        slide_data = slides_data[idx] if idx < len(slides_data) else None
        if not slide_data or not slide_data.get("content"):
            continue

        content_soup = BeautifulSoup(slide_data["content"], "html.parser")
        divs = content_soup.find_all("div", attrs={"class": True})
        if not divs:
            continue

        logger.debug(
            f"Slide {idx + 1}: found {len(divs)} styled <div> candidates in HTML content"
        )

        # Best-effort map of existing picture shapes by basename to allow replacement.
        pptx_pics = [s for s in slide.shapes if s.shape_type == MSO_SHAPE_TYPE.PICTURE]
        basename_map: Dict[str, List[Shape]] = {}
        for pic in pptx_pics:
            try:
                fname = os.path.basename(pic.image.filename)
                basename_map.setdefault(fname, []).append(pic)
            except Exception:
                continue

        for d_i, div in enumerate(divs):
            _class_attr_raw = div.get("class")
            class_attr: List[str] = list(_class_attr_raw) if _class_attr_raw else []
            if any("marp" in c for c in class_attr):
                logger.debug(
                    f"  Slide {idx + 1} div {d_i}: skipping marp-managed element"
                )
                continue

            div_style_raw = div.get("style") or ""
            has_img = bool(div.find("img")) or (
                "background-image" in str(div_style_raw)
            )
            if not has_img:
                continue

            # Resolve relative <img src> paths against the HTML file folder so
            # rendering can find locally generated assets (e.g. orig.png).
            img_tag = div.find("img")
            if img_tag and img_tag.has_attr("src"):
                src_val = str(img_tag.get("src") or "")
                if src_val and not re.match(r"^[a-zA-Z][a-zA-Z0-9+.-]*://", src_val):
                    src_path = Path(src_val)
                    if not src_path.is_absolute():
                        resolved = (html_path.parent / src_path).resolve()
                        if resolved.is_file():
                            img_tag["src"] = str(resolved)
            
    
            png_file = render_div_as_image(
                div,
                css=global_css,
                save_copy_to=html_path.parent / "rendered_divs"  if save_rendered_divs else None,
                slide_index=idx,
                div_index=d_i,
            )
            if not png_file:
                logger.debug(f"  Slide {idx + 1} div {d_i}: render failed")
                continue

            logger.info(f"  Slide {idx + 1} div {d_i}: rendered -> {png_file}")

            # Try to replace an existing picture with the same basename
            replaced = False
            img_tag = div.find("img")
            if img_tag and img_tag.has_attr("src"):
                src_basename = os.path.basename(img_tag["src"].split("?")[0])
                candidates = basename_map.get(src_basename, [])
                if candidates:
                    target_pic = candidates.pop(0)

                    # Prefer in-place image-part replacement (preserves shape formatting).
                    try:
                        # Find the rId for the picture's blip and replace its part blob.
                        blip = target_pic._element.xpath(".//a:blip")[0]
                        rId = blip.get(
                            "{http://schemas.openxmlformats.org/officeDocument/2006/relationships}embed"
                        ) or blip.get("r:embed")
                        if rId:
                            try:
                                img_part = slide.part.related_part(rId)
                            except Exception:
                                img_part = None

                            if img_part is not None:
                                with open(png_file, "rb") as _f:
                                    img_part._blob = _f.read()
                                logger.info(
                                    f"    Replaced image blob in-place for shape (rId={rId})"
                                )
                                replaced = True
                    except Exception:
                        logger.debug("    In-place image replacement failed", exc_info=True)

                    # If in-place replacement didn't succeed, fall back to replacing shape by
                    # adding a new picture and removing the old one (keeps z-order predictable).
                    if not replaced:
                        try:
                            left, top, width, height = (
                                target_pic.left,
                                target_pic.top,
                                target_pic.width,
                                target_pic.height,
                            )
                            try:
                                target_pic._element.getparent().remove(
                                    target_pic._element
                                )
                            except Exception:
                                logger.debug(
                                    "    Could not remove original picture shape during fallback",
                                    exc_info=True,
                                )
                            replaced = True
                        except Exception as e:
                            logger.debug(f"    Fallback shape-replace failed: {e}")

            if not replaced:
                # Fallback strategy: try to find a *small* existing picture on the slide
                # (likely the portrait placeholder) and replace it. If not found, add
                # the rendered PNG full-width as before.
                try:
                    png_w_px, png_h_px = Image.open(png_file).size
                except Exception:
                    png_w_px = png_h_px = None

                slide_area = slide_width * slide_height
                # candidate pictures that are not full-slide backgrounds
                small_pics = [
                    p for p in pptx_pics if (p.width * p.height) < (slide_area * 0.6)
                ]
                target_pic = None

                if small_pics and png_w_px and png_h_px:
                    # convert PNG css-px -> EMU using Marp's 1280px reference
                    try:
                        emu_per_css_px = slide_width / 1280.0
                        expected_w = int(png_w_px * emu_per_css_px)
                        expected_h = int(png_h_px * emu_per_css_px)
                        expected_area = expected_w * expected_h
                        target_pic = min(
                            small_pics,
                            key=lambda s: abs((s.width * s.height) - expected_area),
                        )
                    except Exception:
                        target_pic = min(small_pics, key=lambda s: s.width * s.height)
                elif small_pics:
                    target_pic = min(small_pics, key=lambda s: s.width * s.height)

                if target_pic:
                    try:
                        left, top, width, height = (
                            target_pic.left,
                            target_pic.top,
                            target_pic.width,
                            target_pic.height,
                        )
                        slide.shapes.add_picture(
                            png_file, left, top, width=width, height=height
                        )
                        try:
                            target_pic._element.getparent().remove(target_pic._element)
                        except Exception as e:
                            logger.debug(
                                f"    Could not remove original picture shape during fallback: {e}"
                            )
                        replaced = True
                        logger.info(
                            f"  Slide {idx + 1} div {d_i}: replaced nearest picture shape with rendered PNG"
                        )
                    except Exception as e:
                        logger.debug(
                            f"  Slide {idx + 1} div {d_i}: fallback replacement failed: {e}"
                        )

                if not replaced:
                    # final fallback: add picture full-width
                    slide.shapes.add_picture(png_file, 0, 0, width=slide_width)

            # remove temporary PNG unless user asked to keep rendered copies
            try:
                if not (save_rendered_divs):
                    if str(png_file).startswith(tempfile.gettempdir()):
                        os.remove(png_file)
            except Exception:
                logger.debug("process_styled_divs: failed to remove temporary PNG", exc_info=True)
